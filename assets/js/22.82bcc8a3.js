(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{311:function(t,e,s){"use strict";s.r(e);var v=s(14),a=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("说闭包之前先了解几个概念，执行上下文 EC，执行上下文调用栈 ECS，变量对象 VO...")]),t._v(" "),e("h2",{attrs:{id:"执行上下文、执行上下文调用栈、变量对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文、执行上下文调用栈、变量对象"}},[t._v("#")]),t._v(" 执行上下文、执行上下文调用栈、变量对象")]),t._v(" "),e("p",[t._v("执行上下文(execute context，简称 EC)，也叫执行环境，就是代码解析和执行的运行环境。EC 分为三种：全局 EC，函数 EC，eval(不考虑)。"),e("br"),t._v("\n当执行 js 文件时，会创建了一个全局 EC，函数调用也有一个局部 EC，执行上下文的调用在执行上下文调用栈里，栈底永远时全局 EC，栈顶是当前 EC，函数执行完成后会出栈，直到代码执行全部结束，ECS 为空。\nEC 中有变量对象和 scope 属性，变量对象包含当前环境中声明的变量和函数，在创建阶段变量赋值为 undefined，函数名为函数地址的引用，这也是变量提升的原因。"),e("br"),t._v("\n当一个函数执行完成，内部声明的变量和函数会被回收。但是如果这个函数返回一个函数，外部引用函数内部变量，那么这个变量就不会被回收，就产生了闭包。通俗来讲，闭包就是本该被回收的变量没有被回收。")]),t._v(" "),e("h2",{attrs:{id:"闭包的优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包的优缺点"}},[t._v("#")]),t._v(" 闭包的优缺点")]),t._v(" "),e("p",[t._v("优点：")]),t._v(" "),e("ol",[e("li",[t._v("避免全局变量污染，可以防止命名冲突")]),t._v(" "),e("li",[t._v("可以实现模块化")]),t._v(" "),e("li",[t._v("变量持久化，由于变量无法被回收，使得变量一直在内存中")])]),t._v(" "),e("p",[t._v("缺点：闭包导致变量不被回收，导致内存泄漏。")])])}),[],!1,null,null,null);e.default=a.exports}}]);